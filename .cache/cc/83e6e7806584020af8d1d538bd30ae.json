{"id":"node_modules/isolation-forest/dist/index.js","dependencies":[{"name":"E:\\Resources\\Brackets\\02 JavaScript\\anolomy detection\\node_modules\\isolation-forest\\dist\\index.js.map","includedInParent":true,"mtime":499162500000},{"name":"E:\\Resources\\Brackets\\02 JavaScript\\anolomy detection\\node_modules\\isolation-forest\\src\\index.ts","includedInParent":true,"mtime":499162500000},{"name":"E:\\Resources\\Brackets\\02 JavaScript\\anolomy detection\\package.json","includedInParent":true,"mtime":1633006457103},{"name":"E:\\Resources\\Brackets\\02 JavaScript\\anolomy detection\\node_modules\\isolation-forest\\package.json","includedInParent":true,"mtime":1633006422593},{"name":"./iTree","loc":{"line":3,"column":22},"parent":"E:\\Resources\\Brackets\\02 JavaScript\\anolomy detection\\node_modules\\isolation-forest\\dist\\index.js","resolved":"E:\\Resources\\Brackets\\02 JavaScript\\anolomy detection\\node_modules\\isolation-forest\\dist\\iTree.js"},{"name":"knuth-shuffle","loc":{"line":4,"column":22},"parent":"E:\\Resources\\Brackets\\02 JavaScript\\anolomy detection\\node_modules\\isolation-forest\\dist\\index.js","resolved":"E:\\Resources\\Brackets\\02 JavaScript\\anolomy detection\\node_modules\\knuth-shuffle\\index.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar iTree_1 = require(\"./iTree\");\nvar shuffle = require('knuth-shuffle').knuthShuffle;\nvar IsolationForest = /** @class */ (function () {\n    function IsolationForest(numberOfTrees, subsamplingSize) {\n        if (numberOfTrees === void 0) { numberOfTrees = 100; }\n        if (subsamplingSize === void 0) { subsamplingSize = 256; }\n        this.subsamplingSize = subsamplingSize;\n        this.numberOfTrees = numberOfTrees;\n        this.trees = [];\n        this.X = [];\n    }\n    IsolationForest.prototype.fit = function (X) {\n        this.X = X;\n        if (this.X.length < this.subsamplingSize) {\n            this.subsamplingSize = this.X.length;\n        }\n        var heightLimit = Math.ceil(Math.log2(this.subsamplingSize));\n        for (var i = 0; i < this.numberOfTrees; i++) {\n            var subsample = this.getSubsample(this.subsamplingSize);\n            var iTree = new iTree_1.ITree(this.X, heightLimit);\n            this.trees.push(iTree);\n        }\n        return this.trees;\n    };\n    IsolationForest.prototype.scores = function () {\n        return this.predict(this.X);\n    };\n    IsolationForest.prototype.predict = function (X) {\n        var scoreArray = [];\n        for (var _i = 0, X_1 = X; _i < X_1.length; _i++) {\n            var x = X_1[_i];\n            var pathLength = 0;\n            for (var j = 0; j < this.numberOfTrees; j++) {\n                pathLength += this.trees[j].pathLength(x, this.trees[j].getRootNode(), 0);\n            }\n            var meanPathLength = pathLength / this.numberOfTrees;\n            var score = Math.pow(2, -(meanPathLength / iTree_1.averagePathLength(this.subsamplingSize)));\n            scoreArray.push(score);\n        }\n        return scoreArray;\n    };\n    IsolationForest.prototype.getSubsample = function (subsampleSize) {\n        var subsample = [];\n        var data = shuffle(this.X.slice(0));\n        return data.slice(0, subsampleSize);\n    };\n    return IsolationForest;\n}());\nexports.IsolationForest = IsolationForest;\n"},"sourceMaps":{"js":{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;AAAA,iCAAmD;AAEnD,IAAM,OAAO,GAAG,OAAO,CAAC,eAAe,CAAC,CAAC,YAAY,CAAC;AAMtD;IAQE,yBAAY,aAA2B,EAAE,eAA6B;QAA1D,8BAAA,EAAA,mBAA2B;QAAE,gCAAA,EAAA,qBAA6B;QACpE,IAAI,CAAC,eAAe,GAAG,eAAe,CAAC;QACvC,IAAI,CAAC,aAAa,GAAG,aAAa,CAAC;QACnC,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC;QAChB,IAAI,CAAC,CAAC,GAAG,EAAE,CAAC;IACd,CAAC;IAEM,6BAAG,GAAV,UAAW,CAAe;QACxB,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;QACX,IAAI,IAAI,CAAC,CAAC,CAAC,MAAM,GAAG,IAAI,CAAC,eAAe,EAAE;YACxC,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC;SACtC;QACD,IAAM,WAAW,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC;QAE/D,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC,EAAE,EAAE;YAC3C,IAAM,SAAS,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;YAE1D,IAAM,KAAK,GAAU,IAAI,aAAK,CAAC,IAAI,CAAC,CAAC,EAAE,WAAW,CAAC,CAAC;YACpD,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;SACxB;QACD,OAAO,IAAI,CAAC,KAAK,CAAC;IACpB,CAAC;IAEM,gCAAM,GAAb;QACE,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAA;IAC7B,CAAC;IAEM,iCAAO,GAAd,UAAe,CAAe;QAC5B,IAAM,UAAU,GAAa,EAAE,CAAC;QAChC,KAAgB,UAAC,EAAD,OAAC,EAAD,eAAC,EAAD,IAAC,EAAE;YAAd,IAAM,CAAC,UAAA;YACV,IAAI,UAAU,GAAW,CAAC,CAAC;YAC3B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC,EAAE,EAAE;gBAC3C,UAAU,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC,CAAC;aAC3E;YACD,IAAM,cAAc,GAAG,UAAU,GAAG,IAAI,CAAC,aAAa,CAAC;YACvD,IAAM,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,cAAc,GAAG,yBAAiB,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC;YACvF,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;SACxB;QACD,OAAO,UAAU,CAAC;IACpB,CAAC;IAEO,sCAAY,GAApB,UAAqB,aAAqB;QACxC,IAAM,SAAS,GAAG,EAAE,CAAC;QACrB,IAAM,IAAI,GAAiB,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;QACpD,OAAO,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,aAAa,CAAC,CAAC;IACtC,CAAC;IACH,sBAAC;AAAD,CAAC,AAtDD,IAsDC;AAtDY,0CAAe","sourcesContent":["import { averagePathLength, ITree } from './iTree';\n\nconst shuffle = require('knuth-shuffle').knuthShuffle;\n\nexport interface DataObject {\n  [key: string]: number;\n}\n\nexport class IsolationForest {\n  public trees: ITree[];\n  public X: DataObject[];\n\n  private subsamplingSize: number;\n  private numberOfTrees: number;\n  private shuffleData: boolean;\n\n  constructor(numberOfTrees: number = 100, subsamplingSize: number = 256) {\n    this.subsamplingSize = subsamplingSize;\n    this.numberOfTrees = numberOfTrees;\n    this.trees = [];\n    this.X = [];\n  }\n\n  public fit(X: DataObject[]): ITree[] {\n    this.X = X;\n    if (this.X.length < this.subsamplingSize) {\n      this.subsamplingSize = this.X.length;\n    }\n    const heightLimit = Math.ceil(Math.log2(this.subsamplingSize));\n\n    for (let i = 0; i < this.numberOfTrees; i++) {\n      const subsample = this.getSubsample(this.subsamplingSize);\n\n      const iTree: ITree = new ITree(this.X, heightLimit);\n      this.trees.push(iTree);\n    }\n    return this.trees;\n  }\n\n  public scores(): number[] {\n    return this.predict(this.X)\n  }\n\n  public predict(X: DataObject[]): number[] {\n    const scoreArray: number[] = [];\n    for (const x of X) {\n      let pathLength: number = 0;\n      for (let j = 0; j < this.numberOfTrees; j++) {\n        pathLength += this.trees[j].pathLength(x, this.trees[j].getRootNode(), 0);\n      }\n      const meanPathLength = pathLength / this.numberOfTrees;\n      const score = Math.pow(2, -(meanPathLength / averagePathLength(this.subsamplingSize)));\n      scoreArray.push(score);\n    }\n    return scoreArray;\n  }\n\n  private getSubsample(subsampleSize: number): DataObject[] {\n    const subsample = [];\n    const data: DataObject[] = shuffle(this.X.slice(0));\n    return data.slice(0, subsampleSize);\n  }\n}\n"]}},"error":null,"hash":"e6e62cf75307e6b65c728756cea15908","cacheData":{"env":{}}}