{"id":"node_modules/isolation-forest/dist/treeNode.js","dependencies":[{"name":"E:\\Resources\\Brackets\\02 JavaScript\\anolomy detection\\node_modules\\isolation-forest\\dist\\treeNode.js.map","includedInParent":true,"mtime":499162500000},{"name":"E:\\Resources\\Brackets\\02 JavaScript\\anolomy detection\\node_modules\\isolation-forest\\src\\treeNode.ts","includedInParent":true,"mtime":499162500000},{"name":"E:\\Resources\\Brackets\\02 JavaScript\\anolomy detection\\package.json","includedInParent":true,"mtime":1633006457103},{"name":"E:\\Resources\\Brackets\\02 JavaScript\\anolomy detection\\node_modules\\isolation-forest\\package.json","includedInParent":true,"mtime":1633006422593}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar TreeNode = /** @class */ (function () {\n    function TreeNode(X, height, heightLimit) {\n        var _this = this;\n        this.leftChild = undefined;\n        this.rightChild = undefined;\n        this.splitAttribute = undefined;\n        this.splitValue = undefined;\n        this.height = height;\n        this.heightLimit = heightLimit;\n        if (height >= heightLimit || X.length <= 1) {\n            this.X = X;\n            return this;\n        }\n        else {\n            var attributes = this.getAttributes(X[0]);\n            this.splitAttribute = attributes[Math.floor(Math.random() * attributes.length)];\n            var splitAttributeArray = X.map(function (x) { return x[_this.splitAttribute]; });\n            var attributeMax = this.max(splitAttributeArray);\n            var attributeMin = this.min(splitAttributeArray);\n            this.splitValue = Math.random() * (attributeMax - attributeMin) + attributeMin;\n            var dataSplitA = X.filter(function (x) { return x[_this.splitAttribute] < _this.splitValue; });\n            var dataSplitB = X.filter(function (x) { return x[_this.splitAttribute] >= _this.splitValue; });\n            this.leftChild = new TreeNode(dataSplitA, height + 1, heightLimit);\n            this.rightChild = new TreeNode(dataSplitB, height + 1, heightLimit);\n            return this;\n        }\n    }\n    TreeNode.prototype.max = function (arr) {\n        var len = arr.length;\n        var max = arr[0];\n        while (len--) {\n            max = max >= arr[len] ? max : arr[len];\n        }\n        return max;\n    };\n    TreeNode.prototype.min = function (arr) {\n        var len = arr.length;\n        var min = arr[0];\n        while (len--) {\n            min = min >= arr[len] ? arr[len] : min;\n        }\n        return min;\n    };\n    TreeNode.prototype.isExternalNode = function () {\n        return this.leftChild === undefined && this.rightChild === undefined;\n    };\n    TreeNode.prototype.isInternalNode = function () {\n        return this.leftChild !== undefined && this.rightChild !== undefined;\n    };\n    TreeNode.prototype.size = function () {\n        if (this.X !== undefined) {\n            return this.X.length;\n        }\n        return 0;\n    };\n    TreeNode.prototype.getAttributes = function (x) {\n        return Object.keys(x);\n    };\n    return TreeNode;\n}());\nexports.TreeNode = TreeNode;\n"},"sourceMaps":{"js":{"version":3,"file":"treeNode.js","sourceRoot":"","sources":["../src/treeNode.ts"],"names":[],"mappings":"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","sourcesContent":["import { DataObject } from './index';\n\nexport class TreeNode {\n  public leftChild: TreeNode = undefined;\n  public rightChild: TreeNode = undefined;\n  public splitAttribute: string = undefined;\n  public splitValue: number = undefined;\n\n  private X: DataObject[];\n  private height: number;\n  private heightLimit: number;\n\n  private max(arr: number[]): number {\n    let len = arr.length;\n    let max = arr[0];\n\n    while (len--) {\n      max = max >= arr[len] ? max : arr[len];\n    }\n    return max;\n  }\n\n  private min(arr: number[]): number {\n    let len = arr.length;\n    let min = arr[0];\n\n    while (len--) {\n      min = min >= arr[len] ? arr[len] : min;\n    }\n    return min;\n  }\n\n  constructor(X: DataObject[], height: number, heightLimit: number) {\n    this.height = height;\n    this.heightLimit = heightLimit;\n    if (height >= heightLimit || X.length <= 1) {\n      this.X = X;\n      return this;\n    } else {\n      const attributes = this.getAttributes(X[0]);\n      this.splitAttribute = attributes[Math.floor(Math.random() * attributes.length)];\n      const splitAttributeArray = X.map(x => x[this.splitAttribute]);\n      const attributeMax = this.max(splitAttributeArray);\n      const attributeMin = this.min(splitAttributeArray);\n      this.splitValue = Math.random() * (attributeMax - attributeMin) + attributeMin;\n      const dataSplitA = X.filter(x => x[this.splitAttribute] < this.splitValue);\n      const dataSplitB = X.filter(x => x[this.splitAttribute] >= this.splitValue);\n      this.leftChild = new TreeNode(dataSplitA, height + 1, heightLimit);\n      this.rightChild = new TreeNode(dataSplitB, height + 1, heightLimit);\n      return this;\n    }\n  }\n\n  public isExternalNode(): boolean {\n    return this.leftChild === undefined && this.rightChild === undefined;\n  }\n\n  public isInternalNode(): boolean {\n    return this.leftChild !== undefined && this.rightChild !== undefined;\n  }\n\n  public size(): number {\n    if (this.X !== undefined) {\n      return this.X.length;\n    }\n    return 0;\n  }\n\n  private getAttributes(x: DataObject): string[] {\n    return Object.keys(x);\n  }\n}\n"]}},"error":null,"hash":"284b8cc69286013f350329c6fcff2a42","cacheData":{"env":{}}}